## 断路器

> 微服务之间有着错综复杂的依赖关系，服务往往不是百分之百可靠，可能会出现错误或延迟。 那么就需要对可能出现的故障进行容错和隔离，否则就会应用可能被故障拖垮瘫痪。
>
> 分布式容错模式： 断路器

### 目录
* [电路熔断器模式(Circuit Breaker Patten)](#电路熔断器模式)
* [舱壁隔离模式(Bulkhead Isolation Pattern)](#舱壁隔离模式)
* [服务熔断和服务降级](#服务熔断和服务降级)
* [常见的断路器](#常见的断路器)
* [参考](#参考)

### 电路熔断器模式
原理： 在分布式系统中应用电路熔断器模式后，当目标服务慢或者大量超时，调用方能够主动熔断，以防止服务被进一步拖垮；如果情况又好转了，电路又能自动恢复，这就是所谓的弹性容错，系统有自恢复能力。

![具备弹性恢复能力的电路保护器状态图](images/Circuit-Breaker-Patten.png)

* 正常状态下，电路处于关闭状态(Closed)
* 如果调用持续出错或者超时，电路被打开进入熔断状态(Open)，后续一段时间内的所有调用都会被拒绝(Fail Fast)
* 一段时间以后，保护器会尝试进入半熔断状态(Half-Open)，允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态，如果调用成功，则回到电路闭合状态。

### 舱壁隔离模式
该模式像舱壁一样对资源或失败单元进行隔离，如果一个船舱破了进水，只损失一个船舱，其它船舱可以不受影响 。
线程隔离(Thread Isolation)就是舱壁隔离模式的一个例子，假定一个应用程序A调用了Svc1/Svc2/Svc3三个服务，且部署A的容器一共有120个工作线程，采用线程隔离机制，可以给对Svc1/Svc2/Svc3的调用各分配40个线程，当Svc2慢了，给Svc2分配的40个线程因慢而阻塞并最终耗尽，线程隔离可以保证给Svc1/Svc3分配的80个线程可以不受影响，如果没有这种隔离机制，当Svc2慢的时候，120个工作线程会很快全部被对Svc2的调用吃光，整个应用程序会全部慢下来。

* 限流(Rate Limiting/Load Shedder)，服务总有容量限制，没有限流机制的服务很容易在突发流量(秒杀，双十一)时被冲垮。限流通常指对服务限定并发访问量，比如单位时间只允许100个并发调用，对超过这个限制的请求要拒绝并回退。
* 回退(fallback)，在熔断或者限流发生的时候，应用程序的后续处理逻辑是什么？回退是系统的弹性恢复能力，常见的处理策略有，直接抛出异常，也称快速失败(Fail Fast)，也可以返回空值或缺省值，还可以返回备份数据，如果主服务熔断了，可以从备份服务获取数据。

### 服务熔断和服务降级
* 服务熔断：一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护。
* 服务降级：主逻辑失败采用备用逻辑的过程。

共同点： 
1. 目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；
2. 最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；
3. 粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；
4. 自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；

不同点：
1. 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；
2. 管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）
3. 实现方式不太一样

### 常见的断路器
* [Hystrix断路器](../Component/Spring/Spring-Cloud/Spring-Cloud-Netflix-Hystrix.md) Spring Cloud构建微服务架构的服务容错保护
* [Sentinel组件](../Component/Sentinel.md)  Alibaba 开源
* [Istio](../Component/Istio.md)

### 参考
* https://www.cnblogs.com/duanxz/p/9641489.html