## Dubbo 的超时机制和重试机制

### 目录
* [超时机制](#超时机制)
* [重试机制](#重试机制)
* [超时重试机制的作用](#超时重试机制的作用)
* [路由机制](#路由机制)
* [参考](#参考)

### 超时机制
* 超时是针对消费端还是服务端？
    * 超时是针对消费端的。消费端发起请求后得到一个ResponseFuture，然后消费端一直轮询这个ResponseFuture直至超时或者收到服务端的返回结果。
* 超时在哪设置？
    * 服务端： 全局控制，接口控制，方法控制
    * 消费端： 全局控制，接口控制，方法控制
* 超时设置的优先级是什么？
    * 消费端 > 服务端
    * 方法控制 > 接口控制 > 全局控制
* 超时的实现原理是什么？
    * dubbo默认采用了netty做为网络组件，它属于一种NIO的模式。消费端发起远程请求后，线程不会阻塞等待服务端的返回，而是马上得到一个ResponseFuture，消费端通过不断的轮询机制判断结果是否有返回。因为是通过轮询，轮询有个需要特别注要的就是避免死循环，所以为了解决这个问题就引入了超时机制，只在一定时间范围内做轮询，如果超时时间就返回超时异常。
* 超时解决的是什么问题？
    * 为了避免因为某种原因导致线程被长时间占用，最终出现线程池用完返回拒绝服务的异常。

### 重试机制
注： 
1. 默认超时： 1s， 默认重试： 2次 `retries="2"`。
2. 服务超时后重试次数 `retries`，0代表不重试。
3. 幂等方法上设置重试次数，非幂等方法上禁止重试。

### 超时重试机制的作用
Dubbo的超时重试机制为服务容错、服务稳定提供了比较好的框架支持。

### 路由机制
Dubbo的路由机制，会把超时的请求路由到其他机器上，而不是本机尝试。

### 参考
* `https://www.cnblogs.com/xuwc/p/8974709.html`